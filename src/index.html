<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Kinetic Sculpture</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
		{
		  "imports": {
			"three": "https://unpkg.com/three@0.142.0/build/three.module.js"
		  }
		}
	</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.142.0/examples/jsm/controls/OrbitControls.js';
        import { HDRCubeTextureLoader } from 'https://unpkg.com/three@0.142.0/examples/jsm/loaders/HDRCubeTextureLoader.js';
        // import { OrbitControls } from 'https://cdn.skypack.dev/three@0.142.0/examples/jsm/controls/OrbitControls.js';
        // import { HDRCubeTextureLoader } from 'https://cdn.skypack.dev/three@0.142.0/examples/jsm/loaders/HDRCubeTextureLoader.js';


        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const particleLight = new THREE.Mesh(
            new THREE.SphereGeometry(4, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        scene.add(particleLight);

        particleLight.add(new THREE.PointLight(0xffffff, 1));

        const renderer = new THREE.WebGLRenderer();
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // renderer.exposure = 1.0;
        renderer.toneMappingExposure = 1.25;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        function onWindowResize() {
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize, false);

        // Controls 
        const controls = new OrbitControls(camera, renderer.domElement);

        // Environment setup
        // const pmremGenerator = new THREE.PMREMGenerator(renderer);
        // THREE.DefaultLoadingManager.onLoad = function () {
        //     pmremGenerator.dispose();
        // };
        // let cubeRenderTarget;
        // let cubeMap = new THREE.CubeTextureLoader()
        //     .setPath('https://raw.githubusercontent.com/mrdoob/three.js/191a1ef699a5d53de2cd645c667e7fee184a18fd/examples/textures/cube/skyboxsun25deg/')
        //     .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg'], function () {
        //         cubeRenderTarget = pmremGenerator.fromCubemap(cubeMap);
        //         cubeMap.encoding = THREE.sRGBEncoding;
        //         cubeMap.needsUpdate = true;
        //     });
        // pmremGenerator.compileCubemapShader();
        // scene.background = cubeMap;


        new HDRCubeTextureLoader()
            .setPath('https://raw.githubusercontent.com/mrdoob/three.js/191a1ef699a5d53de2cd645c667e7fee184a18fd/examples/textures/cube/pisaHDR/')
            .load(['px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr'], function (texture) {
                scene.background = texture;
                scene.environment = texture;
            });

        const textureLoader = new THREE.TextureLoader();
        const carbonDiffuse = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/carbon/Carbon.png');
        carbonDiffuse.encoding = THREE.sRGBEncoding;
        carbonDiffuse.wrapS = THREE.RepeatWrapping;
        carbonDiffuse.wrapT = THREE.RepeatWrapping;
        carbonDiffuse.repeat.x = 10;
        carbonDiffuse.repeat.y = 10;
        const carbonNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/carbon/Carbon_Normal.png');
        carbonNormalMap.wrapS = THREE.RepeatWrapping;
        carbonNormalMap.wrapT = THREE.RepeatWrapping;

        const MATERIAL_CARBON = new THREE.MeshPhysicalMaterial({
            roughness: 0.5,
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            map: carbonDiffuse,
            normalMap: carbonNormalMap
        });


        const normalMapRoughMetal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/water/Water_1_M_Normal.jpg');
        const clearcoatNormalMap = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png');
        const MATERIAL_METAL_RED = new THREE.MeshPhysicalMaterial({
            clearcoat: 1.0,
            metalness: 1.0,
            color: 0xff0000,
            normalMap: normalMapRoughMetal,
            normalScale: new THREE.Vector2(0.15, 0.15),
            clearcoatNormalMap: clearcoatNormalMap,

            // y scale is negated to compensate for normal map handedness.
            clearcoatNormalScale: new THREE.Vector2(2.0, - 2.0)
        });
        const MATERIAL_METAL_GRAY = new THREE.MeshPhysicalMaterial({
            clearcoat: 1.0,
            metalness: 1.0,
            color: 0x535654,
            normalMap: normalMapRoughMetal,
            normalScale: new THREE.Vector2(0.15, 0.15),
            clearcoatNormalMap: clearcoatNormalMap,

            // y scale is negated to compensate for normal map handedness.
            clearcoatNormalScale: new THREE.Vector2(2.0, - 2.0)
        });

        const ROTATION_SPEED_RAD_PER_SEC = Math.PI / 4;
        const polar2Cart = (r, thetaRad) => [r * Math.cos(thetaRad), r * Math.sin(thetaRad)];
        function linspace(start, stop, num, endpoint = true) {
            const div = endpoint ? (num - 1) : num;
            const step = (stop - start) / div;
            return Array.from({ length: num }, (_, i) => start + step * i);
        }

        function getAngleAtTime(t_sec) {
            const periodSec = 2 * Math.PI / ROTATION_SPEED_RAD_PER_SEC;
            return ROTATION_SPEED_RAD_PER_SEC * (t_sec % periodSec);
        }
        function getRadiusAtT(thetaAtTZero, t_sec) {
            const offsetRad = getAngleAtTime(t_sec);
            const thetaAtT = thetaAtTZero - offsetRad;
            return 1.5 + Math.sin(thetaAtT);
        }

        // Geometry
        const verts = [];
        for (const theta of linspace(0, 2 * Math.PI, 100, false)) {
            verts.push(
                polar2Cart(getRadiusAtT(theta, 0), theta)
            );
        }

        const cam = new THREE.Group();
        const camShape = new THREE.Shape();
        for (const [x, y] of verts) {
            camShape.lineTo(x, y);
        }
        camShape.lineTo(verts[0][0], verts[0][1]);
        const camGeometry = new THREE.ExtrudeGeometry(
            camShape,
            {
                steps: 1,
                depth: 0.25,
                bevelEnabled: false,
            }
        );
        const camMesh = new THREE.Mesh(
            camGeometry,
            MATERIAL_METAL_RED
        );
        camMesh.rotation.x = Math.PI / 2;
        cam.add(camMesh);
        cam.add(new THREE.AxesHelper(8));
        scene.add(cam);


        class Ball extends THREE.Group {
            constructor() {
                super();
                this.ball = new THREE.Mesh(
                    new THREE.SphereGeometry(.1, 32, 16),
                    MATERIAL_CARBON
                );
                this.add(this.ball);

                this.string = new THREE.Line(
                    new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, 0),
                    ]),
                    new THREE.LineBasicMaterial({ color: 0xffffff })
                )
                this.add(this.string);
            }

            animate(r) {
                this.position.y = - (0.5 + r);

                this.string.geometry.attributes.position.array[4] = (0.5 + r);
                this.string.geometry.attributes.position.needsUpdate = true;
                this.string.geometry.computeBoundingBox();
                this.string.geometry.computeBoundingSphere();
            }
        }

        class PulleyWheel extends THREE.Group {
            constructor(startingThetaRad, balls) {
                super();
                this.startingThetaRad = startingThetaRad;

                this.wheel = new THREE.Mesh(
                    new THREE.CylinderGeometry(.1, .1, 0.25, 32),
                    MATERIAL_METAL_GRAY
                );
                this.add(this.wheel);

                this.balls = balls;
                for (const ball of balls) {
                    this.add(ball);
                }
            }

            animate(t_sec) {
                const r = getRadiusAtT(this.startingThetaRad, t_sec);
                const [x, y] = polar2Cart(r, this.startingThetaRad);
                this.wheel.position.z = y;
                this.wheel.position.x = -x;

                for (const ball of this.balls) {
                    ball.animate(r);
                }
            }

        }

        const pulleyWheels = [];
        const nRows = 5;
        const nCols = 10;
        const spacing = 0.5;
        const angularSpacing = 2 * Math.PI / nCols;

        for (let col = 0; col < nCols; col++) {
            const balls = [];
            for (let row = 0; row < nRows; row++) {
                const ball = new Ball();
                ball.position.z = (row - (nRows - 1) / 2) * spacing;
                ball.position.x = (col - (nCols - 1) / 2) * spacing;
                balls.push(ball);
            }

            const pulleyWheel = new PulleyWheel(col * angularSpacing, balls);
            pulleyWheels.push(pulleyWheel);
            scene.add(pulleyWheel);
        }

        const clock = new THREE.Clock();

        function animate() {
            const t_sec = clock.getElapsedTime();
            // let delta = clock.getDelta();
            requestAnimationFrame(animate);
            cam.rotation.y = getAngleAtTime(t_sec);
            for (const wheel of pulleyWheels) {
                wheel.animate(t_sec);
            }

            const timer = t_sec * 0.15;
            particleLight.position.x = Math.sin(timer * 7) * 300;
            particleLight.position.y = Math.cos(timer * 5) * 400;
            particleLight.position.z = Math.cos(timer * 3) * 300;


            renderer.render(scene, camera);
        };

        animate();
    </script>
</body>

</html>